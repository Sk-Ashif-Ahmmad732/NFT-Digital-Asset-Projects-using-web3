// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleNFTMarketplace {
    // Contract owner
    address public owner;
    
    // Counter for NFT IDs
    uint256 public nextTokenId;
    
    // Struct to store NFT data
    struct NFT {
        uint256 id;
        address creator;
        address currentOwner;
        uint256 price; // Price in cUSD (or cEUR) - represented in wei
        bool isForSale;
        string metadata; // Could be IPFS hash or other URI
    }
    
    // Mapping from token ID to NFT
    mapping(uint256 => NFT) public nfts;
    
    // Events
    event NFTCreated(uint256 indexed tokenId, address indexed creator);
    event NFTListed(uint256 indexed tokenId, uint256 price);
    event NFTSold(uint256 indexed tokenId, address indexed from, address indexed to, uint256 price);
    event NFTUnlisted(uint256 indexed tokenId);
    
    // Constructor
    constructor() {
        owner = msg.sender;
        nextTokenId = 1;
    }
    
    // Mint a new NFT
    function mintNFT(string memory _metadata) public {
        uint256 tokenId = nextTokenId;
        
        nfts[tokenId] = NFT({
            id: tokenId,
            creator: msg.sender,
            currentOwner: msg.sender,
            price: 0,
            isForSale: false,
            metadata: _metadata
        });
        
        nextTokenId++;
        
        emit NFTCreated(tokenId, msg.sender);
    }
    
    // List NFT for sale
    function listNFT(uint256 _tokenId, uint256 _price) public {
        require(nfts[_tokenId].currentOwner == msg.sender, "Only owner can list NFT");
        require(_price > 0, "Price must be greater than 0");
        
        nfts[_tokenId].price = _price;
        nfts[_tokenId].isForSale = true;
        
        emit NFTListed(_tokenId, _price);
    }
    
    // Buy an NFT
    function buyNFT(uint256 _tokenId) public payable {
        NFT storage nft = nfts[_tokenId];
        
        require(nft.isForSale, "NFT is not for sale");
        require(msg.value >= nft.price, "Insufficient payment");
        require(msg.sender != nft.currentOwner, "Owner cannot buy their own NFT");
        
        address previousOwner = nft.currentOwner;
        uint256 salePrice = nft.price;
        
        // Transfer ownership
        nft.currentOwner = msg.sender;
        nft.isForSale = false;
        nft.price = 0;
        
        // Transfer funds to previous owner
        payable(previousOwner).transfer(salePrice);
        
        // Refund excess payment
        if (msg.value > salePrice) {
            payable(msg.sender).transfer(msg.value - salePrice);
        }
        
        emit NFTSold(_tokenId, previousOwner, msg.sender, salePrice);
    }
    
    // Unlist NFT from sale
    function unlistNFT(uint256 _tokenId) public {
        require(nfts[_tokenId].currentOwner == msg.sender, "Only owner can unlist NFT");
        require(nfts[_tokenId].isForSale, "NFT is not listed");
        
        nfts[_tokenId].isForSale = false;
        nfts[_tokenId].price = 0;
        
        emit NFTUnlisted(_tokenId);
    }
    
    // Get NFT details
    function getNFT(uint256 _tokenId) public view returns (
        uint256 id,
        address creator,
        address currentOwner,
        uint256 price,
        bool isForSale,
        string memory metadata
    ) {
        NFT memory nft = nfts[_tokenId];
        return (
            nft.id,
            nft.creator,
            nft.currentOwner,
            nft.price,
            nft.isForSale,
            nft.metadata
        );
    }
    
    // Get total number of NFTs minted
    function getTotalNFTs() public view returns (uint256) {
        return nextTokenId - 1;
    }
}
